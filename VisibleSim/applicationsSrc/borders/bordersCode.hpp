
/**
 * @file bordersCode.hpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2022-10-13                                                                     
 **/	

#ifndef bordersCode_H_
#define bordersCode_H_

#include "robots/blinkyBlocks/blinkyBlocksSimulator.h"
#include "robots/blinkyBlocks/blinkyBlocksWorld.h"
#include "robots/blinkyBlocks/blinkyBlocksBlockCode.h"
static const int POSITION_MSG_ID = 1001;
static const int LEADER_MSG_ID = 1002;
static const int DISTANCE_MSG_ID = 1003;

using namespace BlinkyBlocks;

class Neighborhood {
    uint8_t validity;
    uint8_t state;
    bool border;
    SCLattice::Direction from,to;
    uint8_t turning;
    bool externalBorder;
    bool isolated;
public:
    Neighborhood()  {
        validity = state=0;
        from=to=SCLattice::Direction::MAX_NB_NEIGHBORS;
        border=false;
        externalBorder=false;
        isolated=true;
    }
    uint8_t getState() const { return state; }
    uint8_t getValidity() const { return validity; }
    int8_t getTurning() const { return turning; }
    bool isExternalBorder() const { return externalBorder; }
    SCLattice::Direction getTo() { return to; }
    //void setNeighbor(short dx,short dy,bool value);
    void setNeighbor(SCLattice::Direction dir,bool value);
    void setExternalBorder(bool v) { externalBorder=v; }
    bool isDefined() { return validity==255; }
    bool isBorder() { return border; }
    bool hasNeighbor(short dx,short dy);
    uint8_t getNeighborCode(SCLattice::Direction dir);
    bool merge(SCLattice::Direction dir,uint8_t code);
    // complete corner information if possible
    void complete();
    void setFromTo(SCLattice::Direction p_from,SCLattice::Direction p_to) {
        from = p_from; to=p_to; border=true;
        switch (from) {
            case SCLattice::North:
                turning = (to==SCLattice::West?-1:(to==SCLattice::East?1:0));
                break;
            case SCLattice::East:
                turning = (to==SCLattice::North?-1:(to==SCLattice::South?1:0));
                break;
            case SCLattice::South:
                turning = (to==SCLattice::East?-1:(to==SCLattice::West?1:0));
                break;
            case SCLattice::West:
                turning = (to==SCLattice::South?-1:(to==SCLattice::North?1:0));
                break;
        }
    }
    void getFromPosition(int &x,int &y) {
        switch (from) {
            case SCLattice::North:
                x = -20;
                y = 0;
                break;
            case SCLattice::East:
                x = 0;
                y = 20;
                break;
            case SCLattice::South:
                x = 20;
                y = 0;
                break;
            case SCLattice::West:
                x = 0;
                y = -20;
                break;
        }
    }
    void getToPosition(int &x,int &y) {
        switch (to) {
            case SCLattice::North:
                x = -20;
                y = 0;
                break;
            case SCLattice::East:
                x = 0;
                y = 20;
                break;
            case SCLattice::South:
                x = 20;
                y = 0;
                break;
            case SCLattice::West:
                x = 0;
                y = -20;
                break;
        }
    }
};


class BordersCode : public BlinkyBlocksBlockCode {
private:
	BlinkyBlocksBlock *module = nullptr;
    Neighborhood neighborhood;
    uint16_t order;
    bool isLeader;
public :
	BordersCode(BlinkyBlocksBlock *host);
	~BordersCode() {};

    Neighborhood getNeiborhood() { return neighborhood; }
/**
  * This function is called on startup of the blockCode, it can be used to perform initial
  *  configuration of the host or this instance of the program.
  * @note this can be thought of as the main function of the module
  */
    void startup() override;

/**
  * @brief Message handler for the message 'position'
  * @param _msg Pointer to the message received by the module, requires casting
  * @param sender Connector of the module that has received the message and that is connected to the sender
  */
   void myPositionFunc(std::shared_ptr<Message>_msg,P2PNetworkInterface *sender);

/**
   * @brief Message handler for the message 'leader'
   * @param _msg Pointer to the message received by the module, requires casting
   * @param sender Connector of the module that has received the message and that is connected to the sender
   */
    void myLeaderFunc(std::shared_ptr<Message>_msg,P2PNetworkInterface *sender);

/**
* @brief Message handler for the message 'distance'
* @param _msg Pointer to the message received by the module, requires casting
* @param sender Connector of the module that has received the message and that is connected to the sender
*/
    void myDistanceFunc(std::shared_ptr<Message>_msg,P2PNetworkInterface *sender);

/**
  * @brief Call by world during GL drawing phase, can be used by a user
  *  to draw custom Gl content into the simulated world
  * @note call is made from World::GlDraw
  */
    void onGlDraw() override;

/*****************************************************************************/
/** needed to associate code to module                                      **/
	static BlockCode *buildNewBlockCode(BuildingBlock *host) {
	    return(new BordersCode((BlinkyBlocksBlock*)host));
	}
/*****************************************************************************/
};

#endif /* bordersCode_H_ */