
/**
 * @file mapElitesCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2024-01-27
 **/

#include "mapElitesCode.hpp"
#include "neural_network.hpp"
#include "robot_utils.hpp"
#include "socket_connector.hpp"
#include "robots/catoms3D/catoms3DMotionEngine.h"
#include "robots/catoms3D/catoms3DRotationEvents.h"
#include <thread>
#include <chrono>
#include <set>
#include <unordered_set>
#include <iomanip>
#include <sstream>

// & Robot Code

mapElitesCode::mapElitesCode(Catoms3DBlock *host) : Catoms3DBlockCode(host), module(host)
{
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host)
        return;

    // Registers a callback (myGoFunc) to the message of type O
    addMessageEventFunc2(GO_MSG_ID,
                         std::bind(&mapElitesCode::myGoFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myBackFunc) to the message of type C
    addMessageEventFunc2(BACK_MSG_ID,
                         std::bind(&mapElitesCode::myBackFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myWakeupFunc) to the message of type E
    addMessageEventFunc2(WAKEUP_MSG_ID,
                         std::bind(&mapElitesCode::myWakeupFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(ACKNOWLEDGE_MSG_ID,
                         std::bind(&mapElitesCode::myAcknowledgeFunc,
                                   this,
                                   std::placeholders::_1,
                                   std::placeholders::_2));

    // Registers a callback (myGoFunc) to the message of type O
    addMessageEventFunc2(BROADCAST_MSG_ID,
                         std::bind(&mapElitesCode::myBroadcastFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // ? set the weights of the neural network
    // TODO set the weights from the socket
    // 25, 2, 25, 27

    // vector<vector<vector<double>>> weights = nn.generateRandomWeights();
    if (Utils::areWeightsReceived()) {
        vector<vector<vector<double>>> weights = Utils::getWeights();
        nn.setWeights(weights);
    } else {
        if (client.connectToServer()) {
            vector<double> weights = client.receiveDataVector();
            // nn.reshapeWeights(weights);
            vector<vector<vector<double>>> w = nn.reshapeWeights(weights);
            Utils::setWeightsReceived(true);
            Utils::setWeights(w);
            cout << "Weights received" << endl;
        } else {
            console << "Failed to connect to the server" << "\n";
            cout << "Failed to connect to the server" << endl;
        }
    }
    nn.setActivationFunction("relu");
    nn.setActivationFunctionOutput("relu");
}

void mapElitesCode::startup()
{
    // console << "start " << getId() << "\n";
    // console << "isInTarget" << target->isInTarget(module->position) << "\n";

    if (isLeader)
    {
        console << "start " << getId() << "\n";
        module->setColor(RED);
        // nbWaitedAnswers = sendMessageToAllNeighbors("distance", new MessageOf<int>(BROADCAST_MSG_ID, distance + 1), 1000, 100, 0);

        // move forward
        // ! be careful to use the onMotionEnd function to check if the motion is ended

        vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
        console << "motions size : " << motions.size() << "\n";
        auto motion=motions.begin();
        bool found=false;

        Cell3DPosition position = module->position;
        console << "module position : " << position << "\n";

        while (motion!=motions.end() && !found) {
            console << motion->second.pivot << "\n";
            int pivotPort = findNeighborPort((*motion).second.pivot);
            console << "pivotPort : " << pivotPort << "\n";
            Cell3DPosition finalPos;

            short finalOrient;  
            (*motion).second.getFinalPositionAndOrientation(finalPos, finalOrient);
            Cell3DPosition d = finalPos - position;
            console << "finalPos : " << finalPos << "\n";
            console << "finalOrient : " << finalOrient << "\n";
            // elem.first->isOctaFace(), elem.first->getConFromID(),elem.first->getConToID(),
            console << "isOctaFace : " << (*motion).first->isOctaFace() << "\n";
            console << "getConFromID : " << (*motion).first->getConFromID() << "\n"; // same as pivotPort
            console << "getConToID : " << (*motion).first->getConToID() << "\n";
            console << "(dx, dy, dz) : " << d << "\n";
            motion++;
        }

        // moveToFirst();
        // moveToN(0);
        this->onMotionEnd();
    }
}
void mapElitesCode::myGoFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    MessageOf<int> *msg = static_cast<MessageOf<int> *>(_msg.get());
    int msgData = *msg->getData();
}

void mapElitesCode::myBackFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    // MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    // int msgData = *msg->getData();
}

void mapElitesCode::myWakeupFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
}

void mapElitesCode::myAcknowledgeFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{

    // ? la fonction Acknowledge sert à retourner le message de confirmation de la réception du message broadcast

    nbWaitedAnswers--; // on diminue le nombre de messages attendus, en effet on a reçu la confirmation d'un module
    console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "";
    if (nbWaitedAnswers == 0)
    { // si on a reçu toutes les confirmations
        if (parent == nullptr)
        { // si on est le leader
            setColor(-1);
        }
        else
        { // sinon on envoie un message de confirmation au parent
            sendMessage("ack2parent", new Message(ACKNOWLEDGE_MSG_ID), parent, 1000, 100);
        }
    }
}

void mapElitesCode::myBroadcastFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    // no broadcast in this version
}

void mapElitesCode::parseUserBlockElements(TiXmlElement *config)
{
    const char *attr = config->Attribute("leader");
    isLeader = (attr ? Simulator::extractBoolFromString(attr) : false);
    if (isLeader)
    {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
}

void mapElitesCode::onTap(int face)
{
    // use onTap by ctrl + right click and then select "Tap"
    std::cout << "Block 'tapped':" << getId() << std::endl; // complete with your code here
    moveToN(1);
    std::cout << "Current Position: " << module->position << std::endl;

}

void mapElitesCode::onMotionEnd()
{

    // clear the taken destination
    vector<int> posVect = {module->position[0], module->position[1], module->position[2]};
    Utils::removeTakenDestination(posVect); 

    // use onMotionEnd by ctrl + right click and then select "MotionEnd"
    moveTo++;
    // std::cout << "Motion ended" << std::endl; // complete with your code here
    isMoving = false;
    numberOfMoves--;
    if (numberOfMoves > 0) { // do not move if we have reached the limit of moves
        // wait one second before moving again
        scheduler->schedule(new InterruptionEvent<int>(scheduler->now() + 1, module, 1)); // time is in microseconds
    }
}

int mapElitesCode::findNeighborPort(const Catoms3DBlock *neighbor) {
            int i=0;
  while (i<FCCLattice::MAX_NB_NEIGHBORS && module->getNeighborBlock(i)!=neighbor) {
            i++;
  }
  return (i<FCCLattice::MAX_NB_NEIGHBORS?i:-1);
}

void mapElitesCode::moveToN(int n) {
    // move to the nth possible rotation
    isMoving = true;
    Utils::incrementMotionsProcessed(); // ! important to increment the motions processed counter
    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
    auto motion=motions.begin();
    int i=0;
    bool found=false;
    Cell3DPosition position = module->position;
    while (i < n) {

        if (motion==motions.end()) {
            console << "No motion found" << "\n";
            cout << "No motion found" << endl;
            return;
        }
        i++;
        motion++;
    }
    if (i==n) {
        scheduler->schedule(new Catoms3DRotationStartEvent(scheduler->now() + 1000, module, (*motion).second));
        found=true;
    }
}

int getMaxIndex(vector<double> output) {
    int index = 0;
    double max = output[0];
    for (int i = 1; i < output.size(); i++) {
        if (output[i] > max) {
            max = output[i];
            index = i;
        }
    }
    return index;
}

void mapElitesCode::onInterruptionEvent(shared_ptr<Event> event) {

    auto data = dynamic_cast<InterruptionEvent<int> *>(event.get())->data;


    if (data == 2) { // no move interruption (to simulate the same duration as a normal move)
        this->onMotionEnd();
        return;
    }

    // show the robots around
    vector<bool> robotsAround = getRobotsArround(2);
    // printRobotsAround(robotsAround);
    // convert the bool to double
    vector<double> robotsAroundDouble(robotsAround.begin(), robotsAround.end());

    // print the input
    // cout << "Input : ";
    // for (auto &in : robotsAroundDouble) {
    //     cout << in << " ";
    // }
    // cout << endl;

    vector<double> output = nn.feedForward(robotsAroundDouble);
    // print the output
    // cout << "Output : ";
    // for (auto &out : output) {
    //     cout << out << " ";
    // }
    // cout << endl;

    computePossibleMoves();
    int bestMove = getBestMoveIndex(output);
    moveFromOutput(bestMove);
}

void mapElitesCode::onEndOfSimulation() {
    // !! the onEndOfSimulation function is called at the end of the simulation for only ONE module !!
    console << "End of simulation" << "\n";
    cout << "End of simulation" << endl;
    
    // ? so we need to get all the modules from the world
    map<bID, BaseSimulator::BuildingBlock *> modules = BaseSimulator::getWorld()->getMap();
    // get all leaders
    for (auto &elem : modules) { // ? iterate over all modules
        mapElitesCode *blockCode = dynamic_cast<mapElitesCode *>(elem.second->blockCode); // ? typecast the blockcode to mapElitesCode to access the isLeader variable (and specific module data)
        if (blockCode->isLeader) { // ? check if the module is a leader
            console << "Leader Id : " << elem.first << "\n";
            cout << "Leader Id : " << elem.first << endl;
            blockCode->module->setColor(WHITE);
            console << "Final position : " << blockCode->module->position << "\n"; // ? print the final position of the leader
            cout << "Final position : " << blockCode->module->position << endl;
            console << "Module Id" << elem.first << "\n";
            cout << "Module Id" << elem.first << endl;
        }
    }

    // testing the getEndOfSimulationPositions function
    cout << "End of simulation positions :" << endl;
    vector<vector<int>> positions = getEndOfSimulationPositions();
    for (auto &pos : positions) {
        cout << "Position : " << pos[0] << ", " << pos[1] << ", " << pos[2] << endl;
    }

    // testing the getTotalNumberOfMoves function
    cout << "Total number of moves : " << getTotalNumberOfMoves() << endl;

    // send the data back to the server
    if (client.isConnected()) {
        // convert the whole vector to a string
        std::ostringstream positions_stream;
        for (auto &pos : positions) {
            for (auto &p : pos) {
                positions_stream << p << " ";
            }
        }
        std::string positions_str = positions_stream.str();

        // Remove the trailing space
        if (!positions_str.empty()) {
            positions_str.pop_back();
        }

        // size_t size = positions_str.size();
        // string size_str = to_string(size);
        // client.sendData(size_str.c_str(), "SIZE");

        client.sendData(positions_str.c_str(), "POSITIONS");

        // finally send the total number of moves
        int totalMoves = getTotalNumberOfMoves();
        string totalMoves_str = to_string(totalMoves);
        client.sendData(totalMoves_str.c_str(), "TOTAL_MOVES");
    } else {
        console << "Failed to connect to the server" << "\n";
        cout << "Failed to connect to the server" << endl;
    }
}

// & utilities

void mapElitesCode::computePossibleMoves() {

    possibleMoves.clear(); // ! important to clear the map before adding new values

    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions = Catoms3DMotionEngine::getAllRotationsForModule(module);
    Cell3DPosition position = module->position;

    int i = 0;
    for (auto &motion:motions) {
        Cell3DPosition finalPos;
        short finalOrient;
        motion.second.getFinalPositionAndOrientation(finalPos, finalOrient);

        Cell3DPosition d = finalPos - position;
        vector<int> move = {d[0], d[1], d[2]};

        possibleMoves[move] = i;
        i++;
    }
    
    // ad the (0,0,0) move
    possibleMoves[{0,0,0}] = i;
}

/**
 * @brief Get the index of the best move from the output of the neural network
 * 
 * @param output output of the neural network
 * @return int index of the best move (index of the output)
 * @note use the moveFromOutput function to get the move from the given index
*/
int mapElitesCode::getBestMoveIndex(vector<double> output) {

    int index = -1;
    double max = -INFINITY;

    for (int i = 0; i < output.size(); i++) {
        if (possibleMoves.find(NNMovesMapping[i]) != possibleMoves.end()) {

            if (Utils::isDestinationTaken({module->position[0] + NNMovesMapping[i][0], module->position[1] + NNMovesMapping[i][1], module->position[2] + NNMovesMapping[i][2]})) {
                continue;
            }

            if (output[i] > max) {
                max = output[i];
                index = i;
            }
        }
    }
    return index;
}

void mapElitesCode::moveFromOutput(int index) {

    vector<int> destinationVector = {module->position[0] + NNMovesMapping[index][0], module->position[1] + NNMovesMapping[index][1], module->position[2] + NNMovesMapping[index][2]};
    Utils::addTakenDestination(destinationVector); // ! important to keep track of the taken destinations, release this position when the motion is ended

    if (index == -1) {
        console << "No move found" << "\n";
        cout << "No move found" << endl;
        this->onMotionEnd();
        return;
    }

    vector<int> nullvect = {0,0,0};
    if (NNMovesMapping[index] == nullvect) {
        scheduler->schedule(new InterruptionEvent<int>(scheduler->now() + Catoms3DRotation::ANIMATION_DELAY, module, 2)); // get the normal move duration and send it as a data=2 interruption type
    } else {
        moveToN(possibleMoves[NNMovesMapping[index]]);
    }
}

map<bID, BaseSimulator::BuildingBlock *> mapElitesCode::getLeaders() {
    map<bID, BaseSimulator::BuildingBlock *> modules = BaseSimulator::getWorld()->getMap();
    map<bID, BaseSimulator::BuildingBlock *> leaders;
    for (auto &elem : modules) {
        mapElitesCode *blockCode = dynamic_cast<mapElitesCode *>(elem.second->blockCode);
        if (blockCode->isLeader) {
            leaders[elem.first] = elem.second;
        }
    }
    return leaders;
}

vector<vector<int>> mapElitesCode::getEndOfSimulationPositions() {
    vector<vector<int>> positions;

    map<bID, BaseSimulator::BuildingBlock *> modules = BaseSimulator::getWorld()->getMap();
    for (auto &elem : modules) {
        mapElitesCode *blockCode = dynamic_cast<mapElitesCode *>(elem.second->blockCode);
        if (blockCode->isLeader) {
            vector<int> pos = {blockCode->module->position[0], blockCode->module->position[1], blockCode->module->position[2]};
            positions.push_back(pos);
        }
    }

    return positions;
}

int mapElitesCode::getTotalNumberOfMoves() {
    return Utils::getMotionsProcessed();
}

vector<bool> mapElitesCode::getRobotsArround(int radius) {

    int diameter = 2*radius + 1;
    vector<bool> robotsArround = vector<bool>(diameter*diameter*diameter, false);
    Cell3DPosition position = module->position;
    map<bID, BaseSimulator::BuildingBlock *> modules = BaseSimulator::getWorld()->getMap();

    for (auto &elem : modules) {
        mapElitesCode *blockCode = dynamic_cast<mapElitesCode *>(elem.second->blockCode);
        Cell3DPosition neighborPos = blockCode->module->position;
        if (Utils::getCubeDistance({position[0], position[1], position[2]}, {neighborPos[0], neighborPos[1], neighborPos[2]}) <= radius) {
            int x = neighborPos[0] - position[0] + radius; // 0 <= x < diameter
            int y = neighborPos[1] - position[1] + radius; // 0 <= y < diameter
            int z = neighborPos[2] - position[2] + radius; // 0 <= z < diameter
            robotsArround[x + diameter*y + diameter*diameter*z] = true;
        }
    }

    return robotsArround;
}

void mapElitesCode::printRobotsAround(vector<bool> robotsAround) {
    int diameter = round(pow(robotsAround.size(), 1.0/3.0));
    int radius = (diameter - 1) / 2;
    int lineWidth = max(diameter*2 + 5, static_cast<int>(strlen("Z Level : -1")) + 2);
    cout << "^   " << endl;
    cout << "|   " << endl;
    cout << "Y   " << endl;
    cout << " X->" << endl;
    cout << "-----------------------" << endl;

    stringstream ss;
    for (int z = 0; z < diameter; z++) {
        ss << "Z Level : " << z - radius;
        cout << setw(lineWidth) << left << ss.str();
        ss.str("");
    }
    cout << endl;

    for (int y = diameter-1; y >= 0; y--) {
        for (int z = 0; z < diameter; z++) {
            stringstream ss;
            ss << "[ ";
            for (int x = 0; x < diameter; x++) {
                ss << robotsAround[x + diameter*y + diameter*diameter*z] << " ";
            }
            ss << "]";
            cout << setw(lineWidth) << left << ss.str();
        }
        cout << endl;
    }
    cout << "-----------------------" << endl;
}
