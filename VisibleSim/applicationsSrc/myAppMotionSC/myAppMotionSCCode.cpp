
/**
 * @file myAppMotionSCCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2023-02-10                                                                     
 **/
 
#include "myAppMotionSCCode.hpp"

Cell3DPosition goalPosition(1,5,0);

MyAppMotionSCCode::MyAppMotionSCCode(SlidingCubesBlock *host):SlidingCubesBlockCode(host),module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    // Registers a callback (myElectFirstFunc) to the message of type L
    addMessageEventFunc2(ELECTFIRST_MSG_ID,
                       std::bind(&MyAppMotionSCCode::myElectFirstFunc,this,
                       std::placeholders::_1, std::placeholders::_2));

}

void MyAppMotionSCCode::startup() {
    console << "start " << getId() << "\n";

    if (isLeader) { // At least one module must be "leader" in the config file
        setColor(RED);
        console << "I'm the leader!" << "\n";
        tryToMove();
    }
}

bool MyAppMotionSCCode::tryToMove() {
    if (module->position==goalPosition) return true;
    // try top right
    /*auto nextPos = module->position + Cell3DPosition(0, 1, 1);
    if (module->canMoveTo(nextPos)) {
        console << "moveTo" << nextPos << "\n";
        module->moveTo(nextPos);
        return true;
    }
    // try right same level
    nextPos = module->position + Cell3DPosition(0, 1, 0);
    if (module->canMoveTo(nextPos)) {
        console << "moveTo" << nextPos << "\n";
        module->moveTo(nextPos);
        return true;
    }
    // try bottom right
    nextPos = module->position + Cell3DPosition(0, 1, -1);
    if (module->canMoveTo(nextPos)) {
        console << "moveTo" << nextPos << "\n";
        module->moveTo(nextPos);
        return true;
    }*/
    auto motions = module->getAllMotions();
    cout << "#motions=" << motions.size() << endl;
    pair<Cell3DPosition,uint8_t> *best=nullptr;

    int best_distance=abs(module->position[1]-goalPosition[1]);
    for (auto &motion:motions) {
        int d = abs(motion.first[1]-goalPosition[1]);
        cout << motion.first << "," << int(motion.second) << ":" << d << endl;
        if (d<best_distance || (d==best_distance && rand()%3==1 )) {
            cout << "best" << endl;
            best = &motion;
            best_distance = d;
        }
    }
    if (best!=nullptr) {
        module->moveTo(best->first);
        return true;
    }
    return false;
}

void MyAppMotionSCCode::myElectFirstFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
    // send the message to all neighbors but the sender
    auto neighbors = sendMessageToAllNeighbors("Elect",new Message(ELECTFIRST_MSG_ID), 200000, 0,1,sender);
    if (neighbors==0) {
        setColor(RED);
        tryToMove();
    } else {
        setColor(BLUE);
    }
}

void MyAppMotionSCCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("leader");
    isLeader = (attr?Simulator::extractBoolFromString(attr):false);
    if (isLeader) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
}

void MyAppMotionSCCode::onMotionEnd() {
    if (!tryToMove()) {
        setColor(ORANGE);
        sendMessageToAllNeighbors("Elect",new Message(ELECTFIRST_MSG_ID), 200000, 0,0);
    }
}

void MyAppMotionSCCode::parseUserElements(TiXmlDocument *config) {
    TiXmlNode *vs = config->FirstChild("vs");
    if (!vs) return;
    TiXmlNode *node = vs->FirstChild("goal");
    if (!node) return;
    TiXmlElement *element = node->ToElement();
    const char *attr = element->Attribute("position");
    if (attr) {
        goalPosition=Simulator::extractCell3DPositionFromString(attr);
        std::cout << "goalPosition = " << goalPosition << std::endl;
    }
}

void MyAppMotionSCCode::onGlDraw() {
    static const float thick=0.8;
    static const float color[4]={2.2f,0.2f,0.2f,1.0f};
    const Cell3DPosition& gs = lattice->gridSize;
    const Vector3D gl = lattice->gridScale;
    glDisable(GL_TEXTURE);
    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,color);
    glPushMatrix();
    glNormal3f(0,0,1);
    glScalef(gl[0],gl[1],gl[2]);
    glTranslatef(goalPosition[0],goalPosition[1],goalPosition[2]-0.49);
    glBegin(GL_QUAD_STRIP);
    for (int i=0; i<=36; i++) {
        double cs=0.5*cos(i*M_PI/18);
        double ss=0.5*sin(i*M_PI/18);
        glVertex3f(thick*cs,thick*ss,0);
        glVertex3f(cs,ss,0);
    }
    glEnd();
    glPopMatrix();
}