
/**
 * @file test1NNCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2024-01-27
 **/

#include "test1NNCode.hpp"
#include "neural_network.hpp"
#include "robots/catoms3D/catoms3DMotionEngine.h"
#include "robots/catoms3D/catoms3DRotationEvents.h"
#include <thread>
#include <chrono>
#include <cstdlib>
#include <ctime>

std::vector<std::vector<std::vector<double>>> generateRandomWeights(int dim1, int dim2, int dim3) {
    srand(time(0)); // seed the random number generator
    std::vector<std::vector<std::vector<double>>> weights(dim1, std::vector<std::vector<double>>(dim2, std::vector<double>(dim3)));
    for (int i = 0; i < dim1; ++i) {
        for (int j = 0; j < dim2; ++j) {
            for (int k = 0; k < dim3; ++k) {
                weights[i][j][k] = static_cast<double>(rand()) / RAND_MAX; // generate a random double between 0 and 1
            }
        }
    }
    return weights;
}

test1NNCode::test1NNCode(Catoms3DBlock *host) : Catoms3DBlockCode(host), module(host)
{
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host)
        return;

    // Registers a callback (myGoFunc) to the message of type O
    addMessageEventFunc2(GO_MSG_ID,
                         std::bind(&test1NNCode::myGoFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myBackFunc) to the message of type C
    addMessageEventFunc2(BACK_MSG_ID,
                         std::bind(&test1NNCode::myBackFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // Registers a callback (myWakeupFunc) to the message of type E
    addMessageEventFunc2(WAKEUP_MSG_ID,
                         std::bind(&test1NNCode::myWakeupFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(ACKNOWLEDGE_MSG_ID,
                         std::bind(&test1NNCode::myAcknowledgeFunc,
                                   this,
                                   std::placeholders::_1,
                                   std::placeholders::_2));

    // Registers a callback (myGoFunc) to the message of type O
    addMessageEventFunc2(BROADCAST_MSG_ID,
                         std::bind(&test1NNCode::myBroadcastFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    // ? set the weights of the neural network
    // vector<vector<vector<double>>> weights = {{{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}}, {{0, 0, 0, 1}, {1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}}; // 0 -> 2, 2 -> 4, 4 -> 6, 6 -> 0
    // generate random wieghts
    vector<vector<vector<double>>> weights = generateRandomWeights(2, 4, 4);
    // print the weights
    for (int i = 0; i < weights.size(); i++) {
        for (int j = 0; j < weights[i].size(); j++) {
            for (int k = 0; k < weights[i][j].size(); k++) {
                cout << weights[i][j][k] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }

    nn.setActivationFunction("relu");
    nn.setWeights(weights);
}

void test1NNCode::startup()
{
    // console << "start " << getId() << "\n";
    // console << "isInTarget" << target->isInTarget(module->position) << "\n";

    if (isLeader)
    {
        console << "start " << getId() << "\n";
        module->setColor(RED);
        // nbWaitedAnswers = sendMessageToAllNeighbors("distance", new MessageOf<int>(BROADCAST_MSG_ID, distance + 1), 1000, 100, 0);

        // move forward
        // ! be careful to use the onMotionEnd function to check if the motion is ended

        vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
        console << "motions size : " << motions.size() << "\n";
        auto motion=motions.begin();
        bool found=false;
        while (motion!=motions.end() && !found) {
            console << motion->second.pivot << "\n";
            int pivotPort = findNeighborPort((*motion).second.pivot);
            console << "pivotPort : " << pivotPort << "\n";
            console << "can move to pivotPort : " << canMove(pivotPort) << "\n";

            if (pivotPort!=-1 && canMove(pivotPort)) {
                // scheduler->schedule(new Catoms3DRotationStartEvent(scheduler->now() + 1000, module, (*motion).second));
                // found=true;
            }
            motion++;
        }

        // moveToFirst();
        // moveToN(0);
        onMotionEnd();
    }
}
void test1NNCode::myGoFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    MessageOf<int> *msg = static_cast<MessageOf<int> *>(_msg.get());
    int msgData = *msg->getData();
}

void test1NNCode::myBackFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    // MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    // int msgData = *msg->getData();
}

void test1NNCode::myWakeupFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
}

void test1NNCode::myAcknowledgeFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{

    // ? la fonction Acknowledge sert à retourner le message de confirmation de la réception du message broadcast

    nbWaitedAnswers--; // on diminue le nombre de messages attendus, en effet on a reçu la confirmation d'un module
    console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "";
    if (nbWaitedAnswers == 0)
    { // si on a reçu toutes les confirmations
        if (parent == nullptr)
        { // si on est le leader
            setColor(-1);
        }
        else
        { // sinon on envoie un message de confirmation au parent
            sendMessage("ack2parent", new Message(ACKNOWLEDGE_MSG_ID), parent, 1000, 100);
        }
    }
}

void test1NNCode::myBroadcastFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender)
{
    // no broadcast in this version
}

void test1NNCode::parseUserBlockElements(TiXmlElement *config)
{
    const char *attr = config->Attribute("leader");
    isLeader = (attr ? Simulator::extractBoolFromString(attr) : false);
    if (isLeader)
    {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
    }
}

void test1NNCode::onTap(int face)
{
    // use onTap by ctrl + right click and then select "Tap"
    std::cout << "Block 'tapped':" << getId() << std::endl; // complete with your code here
    moveToN(1);
    std::cout << "Current Position: " << module->position << std::endl;

}

void test1NNCode::onMotionEnd()
{
    // use onMotionEnd by ctrl + right click and then select "MotionEnd"
    moveTo++;
    std::cout << "Motion ended" << std::endl; // complete with your code here
    isMoving = false;
    numberOfMoves--;
    if (numberOfMoves > 0) { // do not move if we have reached the limit of moves
        // wait one second before moving again
        scheduler->schedule(new InterruptionEvent<int>(scheduler->now() + 1000000, module, 1)); // time is in microseconds
    }
}

int test1NNCode::findNeighborPort(const Catoms3DBlock *neighbor) {
            int i=0;
  while (i<FCCLattice::MAX_NB_NEIGHBORS && module->getNeighborBlock(i)!=neighbor) {
            i++;
  }
  return (i<FCCLattice::MAX_NB_NEIGHBORS?i:-1);
}

bool test1NNCode::canMove(int port) {
    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
            Catoms3DMotionEngine::getAllRotationsForModule(module);
   for (auto &motion:motions) {
       int pivotPort = findNeighborPort(motion.second.pivot);
       if (pivotPort==port) return true;
  }
  return false;
}

void test1NNCode::moveStupid() {
    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
    auto motion=motions.begin();
    scheduler->schedule(new Catoms3DRotationStartEvent(scheduler->now() + 1000, module, (*motion).second));
}

void test1NNCode::moveToFirst() {
    // move to the first possible rotation
    isMoving = true;
    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
    auto motion=motions.begin();
    bool found=false;
    while (motion!=motions.end() && !found) {
        int pivotPort = findNeighborPort((*motion).second.pivot);
        if (pivotPort!=-1 && canMove(pivotPort)) {
            scheduler->schedule(new Catoms3DRotationStartEvent(scheduler->now() + 1000, module, (*motion).second));
            found=true;
        }
        motion++;
    }
}

void test1NNCode::moveToN(int n) {
    // move to the nth possible rotation
    isMoving = true;
    vector<std::pair<const Catoms3DMotionRulesLink*, Catoms3DRotation>> motions =
          Catoms3DMotionEngine::getAllRotationsForModule(module);
    auto motion=motions.begin();
    int i=0;
    bool found=false;
    while (i < n) {

        if (motion==motions.end()) {
            console << "No motion found" << "\n";
            cout << "No motion found" << endl;
            return;
        }
        i++;
        motion++;
    }
    if (i==n) {
        int pivotPort = findNeighborPort((*motion).second.pivot);
        if (pivotPort!=-1 && canMove(pivotPort)) {
            scheduler->schedule(new Catoms3DRotationStartEvent(scheduler->now() + 1000, module, (*motion).second));
            found=true;
        } else {
            console << "Can't move to pivotPort : " << pivotPort << "\n";
            cout << "Can't move to pivotPort : " << pivotPort << endl;
            return;
        }
    }
}

int getMaxIndex(vector<double> output) {
    int index = 0;
    double max = output[0];
    for (int i = 1; i < output.size(); i++) {
        if (output[i] > max) {
            max = output[i];
            index = i;
        }
    }
    return index;
}

void test1NNCode::onInterruptionEvent(shared_ptr<Event> event) {
    std::cout << "Interruption Ended" << std::endl; // complete with your code here
    vector<double> output = nn.feedForward(previousMoves);
    console << "Output : " << output[0] << ", " << output[1] << ", " << output[2] << ", " << output[3] << "\n";

    // get the index of the maximum value
    int index = getMaxIndex(output);
    moveTo = index*2; // to get the 0, 2, 4, 6
    previousMoves = {0, 0, 0, 0};
    previousMoves[index] = 1;
    moveToN(moveTo);
}
