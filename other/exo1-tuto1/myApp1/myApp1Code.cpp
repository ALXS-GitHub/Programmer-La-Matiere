/**
 * @file myApp1Code.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2022-09-22
 **/

#include "myApp1Code.hpp"

MyApp1Code::MyApp1Code(BlinkyBlocksBlock *host):BlinkyBlocksBlockCode(host),module(host) {
  // @warning Do not remove block below, as a blockcode with a NULL host might be created
  //  for command line parsing
  if (not host) return;

  // Registers a callback (myBroadcastFunc) to the message of type R
  addMessageEventFunc2(BROADCAST_MSG_ID,
                       std::bind(&MyApp1Code::myBroadcastFunc,
                                 this,
                                 std::placeholders::_1,
                                 std::placeholders::_2)
                       );

  // Registers a callback (myAcknowledgeFunc) to the message of type K
  addMessageEventFunc2(ACKNOWLEDGE_MSG_ID,
                       std::bind(&MyApp1Code::myAcknowledgeFunc,
                                 this,
                                 std::placeholders::_1,
                                 std::placeholders::_2)
                       );
}

void MyApp1Code::startup() {
  console << "start " << getId() << "";

  if (isLeader) {
    module->setColor(RED);
    currentRound=1;
    distance=0;
    nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,1)",new MessageOf<pair<int,int>>(BROADCAST_MSG_ID,make_pair(distance+1,currentRound)),1000,100,0);
  } else {
    currentRound=0;
  }
}

void MyApp1Code::myBroadcastFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
  MessageOf<pair<int,int>>* msg = static_cast<MessageOf<pair<int,int>>*>(_msg.get());
  pair<int,int> msgData = *msg->getData();

  console << "rec. Flood (" << msgData.first << "," << msgData.second << ") from " << sender->getConnectedBlockId() << "";

    // ! modif début !
    // ? on regarde à quel round on est (= nombre de fois ou l'on a tapé sur un bloc)
    // ? dans ce cas, on envoie un message à tous les voisins sauf le parent comme dans le code initial

    if (currentRound < msgData.second) {
      currentRound=msgData.second;
      distance=msgData.first;
      setColor(distance);
      parent=sender;
      nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,1)",new MessageOf<pair<int,int>>(BROADCAST_MSG_ID,make_pair(distance+1,currentRound)),1000,100,1,sender);
      if (nbWaitedAnswers==0) {
        sendMessage("ack2parent",new Message(ACKNOWLEDGE_MSG_ID),parent,1000,100);
      }
    } else {
      sendMessage("ack2sender",new Message(ACKNOWLEDGE_MSG_ID),sender,1000,100);
    }

    // ! modif fin !

  if (parent==nullptr || msgData.first<distance) {
    distance=msgData.first;
    setColor(distance);
    currentRound=msgData.second;
    parent=sender;
    string str="distance(";
    str+=to_string(distance+1)+","+to_string(currentRound)+")";
    nbWaitedAnswers=sendMessageToAllNeighbors(str.c_str(),new MessageOf<pair<int,int>>(BROADCAST_MSG_ID,make_pair(distance+1,currentRound)),1000,100,1,sender);
    if (nbWaitedAnswers==0) {
      sendMessage("ack2parent",new Message(ACKNOWLEDGE_MSG_ID),parent,1000,100);
    }
  } else {
    sendMessage("ack2sender",new Message(ACKNOWLEDGE_MSG_ID),sender,1000,100);
  }
}

void MyApp1Code::myAcknowledgeFunc(std::shared_ptr<Message>_msg, P2PNetworkInterface*sender) {
  nbWaitedAnswers--;
  console << "rec. Ack(" << nbWaitedAnswers << ") from " << sender->getConnectedBlockId() << "";
  if (nbWaitedAnswers==0) {
    if (parent==nullptr) {
      setColor(WHITE);
    } else {
      sendMessage("ack2parent",new Message(ACKNOWLEDGE_MSG_ID),parent,1000,100);
    }
  }
}

void MyApp1Code::parseUserBlockElements(TiXmlElement *config) {
  const char *attr = config->Attribute("leader");
  isLeader = (attr?Simulator::extractBoolFromString(attr):false);
  if (isLeader) {
    std::cout << getId() << " is leader!" << std::endl; // complete with your code
  }
}

void MyApp1Code::onUserKeyPressed(unsigned char c, int x, int y) {
  switch (c) {
    case 'a' : // update with your code
      std::cout << "key a" << endl;
      break;
    case 'd' : break;
  }
}

void MyApp1Code::onTap(int face) {
  std::cout << "Block 'tapped:'" << getId() << std::endl; // complete with your code here

    // ! modif début !
    // ? quand on tape sur un bloc, on passe au round suivant en prenant ce bloc comme leader
    isLeader=true; // $ ici je ne pense pas que ce soit utile, mais je le laisse au cas où
    parent = nullptr;
    module->setColor(RED);
    currentRound++;
    distance=0;
    nbWaitedAnswers=sendMessageToAllNeighbors("distance(1,1)",new MessageOf<pair<int,int>>(BROADCAST_MSG_ID,make_pair(distance+1,currentRound)),1000,100,0);
    // ! modif fin !
}